SHA stands for the secure hash algorithm. Which is interesting given that it has just kind of been brokenBut I'm not going to talk specifically about the attack on SHA todaythat's for a different video, butWhat I wanted to do was talk in a little bit more detail about hash functions and what they areAnd how SHA in particular works so you can get an idea of a kind of way these things are implementedlet's have a quick look at what a hash function is briefly because Tom's got somebody covered it in this video andHe's gone into a lot of the reasons you might use a hash function. The kind of hash functionsI'm talking about are not the ones that we've been talking about forHashing passwords. Those ones have to be quite slow in some sense because you need them to be secureWe're going to talk mostly about the hash functions that are used routinely in cryptography for things like message authenticationDigital signatures, and so on. So they need to be fairly quick, both to verify and compute. A hash functionTake some string, right, let's say "abc" and it turns it into some fixed length string(that's not usually three long) of randomSo we know a bit string right, but so so you, 011001011...Go forward this way for however many bits that hash function is. Now, there's a few important properties of Hash functionsThat we care about for cryptography, but the most important one perhaps. Is that it's essentially pseudo-randomSo that means that we put in "abc"And we get out something that is in no way like "abc" and appears completely random to us and if we change this even slightlyBecause it's appearing random this has completely changedSo let's have a quick look at SHA-1 as an example just so we can see this in actionI'm on some page that has a script that calculates hashes on the fly so I can put in "abc" andYou can see that the hash is a9993e and so on all the way up to d, right?This is the SHA1 hash. A SHA1 hash is 160 bits long. If I change thisC to a D the hash is completely changed. So there's the appearance of randomness - the idea thatThis hash is actually not related to this at allEven though it is and we know it is because if I put C back againWe're back to a9993So we can use this to verify messages haven't been changed or verify signatures on certificatesAnd we can do it knowing that we have the appearance of randomness , but actually it's not random at all. TodayWe're going to talk a bit about how you actually write a hash function to do thisHow do we take something that essentially isn't random with a very known structure and turn it into something that looks like nonsenseSuch that we can use it. Now,There'll be people raising a few eyebrows thatI'm using SHA1 as an example to do thisBut actually there's fairly reasonable reason to do so.First of all you know we might also talk about the weaknesses at some pointbut also SHA-1 bears a striking similarity in structure to MD4 and MD5 which is see a lot of use historically andSHA-256 and SHA-512 which is a SHA2Which currently is in some sense a standard that everyone uses right SHA3 is quite differentAnd that's is something else for another daySo SHA1 was developed by the NSAAnd released and published in 1995 now a lot of people don't trust things that the NSA do sort of by defaultWhich might be fair, but in this case actually SHA1 was quite good for a long long timewhen there were some concerns ... recently much more serious concerns, butOriginally the NSA weren't doing it as a back door and stuff the NSA need cryptographyJust like everyone else and this is a good functionMD5 had a lot of problems and so what they basically did was extend it and make it betterSHA1 takes any length of string and outputs a160 bit value. Alright, so that's160 zeros and ones. The question then becomes: I've got a string but could be "abc" or it could be an incredibly long file orYou know a whole movie right, and I want to calculate 160-bit signature of thatHow do I even get started doing that well the answer is that I basically have a loop that takes512 bit blocks of data one at a time until the file's expended. Let's look at an example of how SHA1 works on justa single message of exactly the right lengthAnd then we'll just talk briefly about what you do when inevitably isn't the right lengthWhich is almost always, right? So SHA1 takes a message of n blocks of 512 bits in length, andIf it's only one block - if the message is exactly 512 bits in length, then we only run it once, in essenceAnd then we out put the hash at the end so SHA-1Starts with an internal state then we bring in bits of our message one at a timeAnd we change that internal state and after we've done that at the very end when there's no more message leftWe just read what the internal state is and that's our hash alrightso we're going to basically be taking the internal state and updating it with the message untilWe run out of message, and then as soon as that process stops we can read the resultsThat's how the SHA family of hash functions works, so our internal state we call H so I'm going to say H0H1 H2 H3and H4Now the internal state of SHA1 is exactly the same length as the hash that it produces. Which is 160 bits. Which is five32-bit words four bytes each you know for 32-bit machine this would be an intSo this is initialized based on some constants. Which is defined in the standardWe might talk about that in a bitbut it's not very important and what we're going to do is we're update these h's asWe bring in our message and then at the end. We'll see what the Hs are and that's our hash functionSo how do we do this? Well? We have something [called] a compression function?It's going to take in this data and a bit of messageTurn it into another set of h values and that's going to repeat as we have messageBut that's only going to happen once this time because my message is exactly 5 12, which is very handySo this is our compression functionAnd I'm going to rename these slightly just to confuse everyone to ABc dearly so at the beginning of our compression functionWe copy B's the internal state into a b c d and eWe then perform 80 rounds of char compression function, right?Which is like this so x 80 now what that's going to do is take in words from our512 bit block of our message, so if this is our message here that message is512 bits this is going to come in at this point and be mixed in with this ABc and D so well for nowWe won't talk about exactly what's going on in this compression functionBut the idea is that the bits of abcde are being combined together? They're being shuffledThey're being commuted around to make it look more and more random as we go and at the same timeWe're bringing in bits from this message to further increase the appearance of mandamusBut also to make sure that this shower function is calculating a digest on this specific message rather than just a general oneThat's the same every time for this message. We're always going to perform the exact same algorithmSo if we put in this message a second time the shower function will produce exactly the same resultNow once we've done this and we shuffled up abcde will be left with a newAbcde so a b c d and eAnd then we finish this block by bringing our h values down here and adding [them] to these values hereto create a newH naughtH1 H2 H3H4 the State is now been updated by whatever we did in this compression function by just adding to it all right now all additionIn Char is done without any overflow modulo 2 to the 32 well that means is that if you ever go over?The maximum value allowed by a 4-byte integer you lap back around againRight which is one of the reasons why shark arm in reverse because you might lose information that wayThis is not encryption. We don't need to be able to reverse it, so this state isFinished now if our message is exactly 512 bitsWe need these 18 or h1 h2 h3 h4 values out that is our hash, so for short messages. We're doneI could just you know go homein actual fact the the principle of extending this to arbitrary length messages right in increments of512 Bits isWe copy this state back up to the top and we repeat the process and then we copy back up and we repeat the processFor as many blocks as we have of our message 512 bits at a time of our messageWe feed it in we alter the state using this approach here, and then we lead off a state when we're done, right?That's basically how it worksSo be the security of SHA is all in this compression function and what it's doing. If it's shorter than that, whathappens there?  If it's not a multiple of 512 bits. We're going to have to do some padding right?Char only works with 512 bit blocks, so what we do is if we have our message. Which is let's say1 0 1 1 0 1 it's not a very long message. If we want to pad that up to 512 bitsWe start with [a] one. We pad with 11 [alright], so I'm going to sort of mark, de-mark the padding hereso we know we go with0000 and then we finish off the message with the length of the actual message in itSo we know where to sort of remove the padding which in this case is 7 so in Binary 1 1 1 so 1 11?Obviously would a lot more bits for your length than I have done. You get the idea now this padding schemeEnsures that messages of the same length and messages that end in the same way or in very similar ways don't share the same paddingAnd don't end up being the same that's very important, so this approach to SHA [its] repetitiveUpdating of the internal state with a compression function in essence is called a merkel down guard constructionThis was sort of independently proved by murkland damn. [God]But essentially what's good about it is if your compression function is good and has good pSeudo-random properties then so does your shower functionWhich is of course very useful right?The problem is that the compression function of char one is not so good that the attacks areTo the 18 they can be reduced somewhat to about 2 to the 60 something like this which it becomesInto the realm of possibility for people with a lot of money