When alex did a video on linked list there's a lot of comments on it it sort of thingI want to use a linked list arrays a factorWhat's the point of reading this and so I was sort of thinking about is that well actually "Are arraysfaster than the linked list or are the linked lists faster than an array, how do we go about finding out?"Which one's faster, so let's have a shoot out arrays versus linked listFirst question to start isI should just remind ourselves what the difference is between a linked list andAn array so let's start with the array so probably the simplestTo understand so an array is just a way of storingseveralvaluesin memory so we start off with the first value andfor the purposes of this demonstration, I'm going to use aStructure containing multiple values. We did talk about objects a while ago structures are what you had beforeWe saw this object which is a collection of values in memories and store to integer valuesSo this is array element zero and it's got two numbers. We then got array element oneAnd it's got two numbersLooks like I'm playing break out got a great elementTo and it's got two numbers and so we can refer to any of thesebyreference to the Index starts at 0 3 4 5 67 10 so you can have an array of any size we have to know how big it is if you wanted to be whenYou create so you allocate the memory for all the things and then?You can store some values so we can write 42 in this one. We can put 21 in hereI'm going to put 3 in that one and we can store them or we can put different values in here asWell as we need them so that's how an array works. Which is one big block of memory each thing stored one after the otherlinked list works slightly different we start off at the beginning ofthe linked list and it points at nothing but then as we add things to the list weAllocate the memory for it. We're going to store two things so the first thing we'll label these things inside it pAnd Q so it's a lot p hereAnd we've got q but we also have an extra thing that tells us where the next they will be and that's empty, tooSo it's all put 42 and 16 so we just allocate space for that oneStructure that one thing that we're going to store and we connect it upSo we point this at the first thing so we often call this something like firstAnd we see Alex videos to see how that have doneSo when we want to store the next thing we allocate explai for another oneAnd we can store the value, so we've still got 821 in it now the difference between this could be anywhere else in memory, and we connect to the next pointerto point inTo the next thing so we have some known starting pointwhich points to the first thing and the first thing 22 the second thing and the second thing would point to the third thing andSo on and that would point down and these could be all overanywhereIn the computer's memory and then at the end you normally point it at some known valueWhich is often referred to as null and is often the number zero?So you can then walk through your listAnd when you find at the next point of zero or null you know you've come to the end of itThere are two different ways of storing data the best or the same amount of data nowHe's got some differences this one as I says it's fixed inside, and you create it you can storeHow many things you know I've actually filled in but as soon as you get more than eleven since final top array?You can't go past eleven if you can see yeah the numbers all go to11 on this however if we wanted to put something else thing we can just get rid of this thingAnd update this to pointTo a new thing so we can make this growQuite easily, and we can also be really cleverWe can add things in the middle and the beginning very very simply, but we're going to go into that todaySo creating them. We're probably only going to do once but which one is actually fasterWell, let's think about what actually to do. Let's define a very very simple problemWe've created the structure here, and it's got two things in itIt's got an integer called p and an integer called Q so saving the linked list and inThe array let's consider an operation where we're just going to go through all the elements in our arrayOr all the elements in our linked list and sum the value of p are going to add up all the valueSo we're going to add up. What's in arrayElement Zeroes P in array of them at once P and so on so we're going to effectively doSomething's going to add them all up. We'll do the same with the linked list as wellSo we're going to set what the first thing is to point to pNow that one. No. There's no time out of its value of p the next one and so on and we'll add them all upWhy are we using missiles they want to the unique thing about this isThat it's going to visit every single element in either the array or every single element in the linked listso we're going to visit every single element if you only have to visit one element then the very nature ofRandom access into array means as we fastThere's no way you can make any difference unless it's the first element if you only one to ever access the first elementThen look at the same speed we fuel directly to random elementThen the array or win hands down you can just think about how it works that will be the case. We're going to considerWe want to access every single element and do something to it and in this caseYou're just going to sum up the values, but it could be if things were representing say windows on the screenWe want to move them around we want to redraw themWhatever it is will then do something to every single wall so we sort of set out the problem?I'm going to go over an array of values and a linked list of valuesI'm going to in sum in the visits all and we do actually add up all the numbersStored in the element P. Which is part of the structure so what I've done is I've writtenTo see poems which are more or less identicalI'm going to create125,000 elements in my arrayor mailing list and in the linked list I've got a structure which contains an integer p and an integer Q andin the array versionI've got a structure which contains an integer p and interested Q in the array itemThe only difference is that the linked list has one extra item which is the next pointer to the next thing?So very listen see so hopefully we'll go as fast as we possibly can most of the rest of the programisidenticalso I have my main Routine here which creates aList or an array of random number generator?125,000 random numbers which is a slowest part of the program you'll see and then store themSo allocate memory for each element in the linked list and then we set the valueEverything else will just leave with 0 and we do the same with the array just as we did on the paperWe then run the program100 times and all going to here is timeHow long it takes to run a function which adds afforda numbers either in the list or in the array?I will do that 100 timesAnd then we can work out the average time it takes to calculate one and we'll print out the values as we goSo we're just using the built-in clock function in C. Which should be accurate accurate enough for what we want to doso the real meat the body of the program is this function here some list orSome arrayLet's start with the array one because possibly the simplest we said a variable to be zero that's going to be asked someYou have another variableI which is going to be our index through the array and we go from I equals zeroI first element until we get to the end the number of elements in thereand we just say this sum equals the value that was already in sum plus the value in the ice element in the array aP elementRemember we said the array had a p and a Q in it we want the value stored in the p space within the structurein our array, so I'm just going to add get them together the list version very very similar we set the someone to be 0We say while p does not equal nullSo why we haven't reached the end of the list and we set p initially to be the first thing in the linked list?So pointing out that first thing sum equals sum plusP inside p. We using P inside pConfusing variable names, but then I'm asleep programmer, and then we set p ir pointer to point to the next thingSo we follow the link to the next thing in the linked list and we keep doing that until we come to the endThere are two programs as simple as you get in terms of implementing a linked list or on arrayso we're going to do is run them andWe should get some values outputBut we're not going to run them on the I max we're not going to run them on the raspberry Piwe're actually going to run them on the atari behind me which means I need a very high Peak high-tech piece ofEquipment, so I need a floppy disk to transfer other programs from the iMacGo topping them off the iMac, and then we can run them on the AtAriso go over to the Atari andAssurance that it's cameras and spot. We can see it. So what I'm gonna do at first is they got to runthe list first also going to generate125,000linked list values to let it RunRight while it loads off the floppy diskthat's what it used to be like back in the 80s and 90s you had to wait one you crave them ran aWhile along WhileAnd this is just a simple programSo there is goodSo it's notInitializing the link list it's allocating all the memory for the different elements and then putting a random numberIn the P value of each one, so we'll let that runIn the words of the old Hobbit computer game time passes or in the words of every apple of thissecret shortHow long does this take?A while lots of oil, I don't know another time this bit125,000 times however long it takes to allocate a random number and allocate some memoryOn the clock speed of what this is actually an 8 MegAhertz cPUSo it's a takes a while the computer loaded off all the code for the program and off the floppy disk into memoryAnd it's now running it to generate the data set that we need then Gonna sum all the valuesSo everything is happening now will happen off memoryIt's just taking a while to process itBut we are recording it in 4k which is a slight overkill. I hope you're getting into thatextra bitSo the programs going through now and we'll let it run 400 timesWe'll get an average, but actually looking at the values of the coming upI think we can safely assume that the average is going to end up being166 clock ticks now when I say qwop takes each of the machines. We're going to look at are going to haveDifferent clocks perms that they use the time things so we can't compare the values directly what we could come read with the secondsBut we can certainly see the relative patterns between it will call that166 clock ticks over to run the linked list version of the program it takes166 clock ticksSo let's now run the array version of the programSo now we're going to do exactly the same thingwe're going to allocate an array every time tWenty-five thousand elements andpopulate them with random values because of the wayI've written the programIt will actually be the same pSeudo random number sequence that the sum should be the same and then we're going to filleach of them up and time how long that takes and we'll they'll see whether an array actually is faster than the linked list orWhether a linked list will be b. ArraySo that to me looks like that little spinny thing is going fasterYeah, well so and I haven't just upgraded the processor while they're off cameraWhat's actually happening is?When we allocate the space for the linked list we have to allocate space for each element and then for the gym thereWe allocate space for the next element. We could do that in a different way and speed things up, but we did itThat's the classic way with the array. We allocate the whole lot in one go, so we all take oneHuge block of memory under 25,000 times eight is about one meg's worth of memorySo allocate all that in one go, and then we're just going through it filling in all the values setting all the valuesSo that should be quickerand it seems and spinning wheel is going slightly faster what why would that Spin wheel very fast can you just learn how thatYou can read it if you've heard this thing you it yeah?So to give some nice sort of visual Feedback while this is runningWell, I'm just a plain white screen what I'm doing is I'm printing every hundred element idealsI update that thing and just printing either a dash aVertical line or one of the two slashes to make it look like it's getting round and those are printing it it creates a littleEffect which is see that something's happened and the computer hasn't crashedSo this should be faster, and we should get a value so is now working and the immediate thing we see isThat the array is taking about179 or178 ticks it's the same quad kick so we can compare these two valuesthe Array isslower than a linked list IKnow down, okay? All right now. So you can't argue in - okay, so the numbers have come in the computers around170 angular call is to that 170 8.5. Always for the final average to come in but for that. So they're roughly comparableBasically there's not much it sort of thing, but there's something about 200 qwop ticks per second on this machineIt's is probably a noticeable. It's about 10 percent slowerOkay, so that's it. I mean we can stop here come a that's it. We know. What's what arrays are slowYou wrinkly yep, so arrays are slower than ling LiGotta get my vendor video yeah and a video you can now bring up the slash computer, sovirtuallyThere are two ways you can walk over the RayWe went up the array from the smaller numbers to the larger numbersBut we could also start at the larger indexes and move back to the smaller indexes, and I thought wellLet's try it both ways let's not have anyone posting some comments saying no, but if you went the other waySo let's run it the other way, so I wrote a version which walks down and because we're adding the numbers togetherWe'll get exactly the same answer a plus b equals b. Plus a and all that you can watch numberphile to find outMore online. I'm sureYou think this would take exactly the same amount of time, so just update our tableTo do this and we're going to have the reverse array hereI'll just wait while it does thatSo going backwards through the array the only thing can we do the same thing with the linked listWell the way we've designed the linked list weHave a pointer to the next thing in each thing, but we don't have a pointer back to the previous thingIt's a singly linked list so we can only move forwards along itWe could design it to be a doubly linked list and have a backwards and forwards pointerbut if you think about it if we started at the endAnd move backwards that's going to be exactly the sameOperations as if we start at the beginning and before so there's actually no point in testingIt'd be exactly the same code. We just be using different offsets into memory so taking exactly the same amount of timeWhile we wait for that to do its thing let's run the same programs onThe Imac and see how much faster it is so let's compile them up. I am turning on as I did before all the optimizationsFor the array and things that'll make it go as fast as poss but some of the comparison to the arrayTest and I going to compile with the speed testDone, and I'm going to do the same thingfor the linkTest I'm going to say something really obvious nowBut it's honestly a heck of a lot quicker this machine just to get compiled up and ready. YeahThose machines much faster because while I'm compiling everything on here and then transferring it acrossRather than trying to get my old C compiler going on the AtAriAnd also the chances are this will produce better code, so it'll take make the most benefit of the speedWe can pile them up, so let's run the linked list test as we did beforeboomIt's doneEverything now you notice that took a lot quicker?The numbers are still roughly in the same order still about 100 and around 200 but remember this is a differentClock we cannot compare the ticks from that one - it's on the different numbers, but we get the average here two hundred and ninePoint five four I'm acting this is 166 atari ticksThey're much slower chicks than the I like ticks we can't compare that to that we can comparehorizontallylet's do the same now with the array test andWowWhen we did the linked list test on the atari it was faster than the array testRoughly take you about ten percent fasterNothing really in it you could say look at the difference onThe Imac the IMac takes forty three point four four clock ticks to do the array209 that's five timesFaster for the Array was on the Atari the linked list was fasterSo a reverse array is now going onthe Atari114 andThat's quicker. That's quicker than the original array, and that's quicker than the linked list, so if we do everything backwardsDoogie where it's very good if you do everything forwardsIt's much slower. I'm a bit confusedIs there any possibility that's just a problem the code or something always are you going to reveal something to this year?We need to delve a bit deeper here to see what's really going onRemember we wrote these programs in CSo we wrote these in the high-level language and then they got compiled downTo the instructions that the machine can execute and what's actually happening here. Is that the research shows that the machine can execute?Favor walking backwards down something compared with going further upwards nowLet's run that same array backwardsProgram on the IMac for completing this so let me compile that one up and again. I'mOptimizing everything to the hiltTest and so we'll run speed tests backAnd we'll run this one so before the arrays now much fasterAccording to this a reversal rate should be faster than the forward array. So what would you expect the value to be shown for?Run on the reverse away about fifteen or twenty directly if it was the same as that didAll rightWould you like to stick with that answer or would you like to change that oh?nervous excited actuallyBecause the Atari was faster to do a linked list in an array and the iMac was the other way aroundI'm going to say it's going to be slower to do it in reverse. So you reckon firm supposed to do it in reverseOh, I do like an indecisive person there. We go average time forty sevenpoint four sixSo marginally slow marginally slower about 10% slowerbut still an order of magnitudefaster than this we could do the same on the raspberry PiSo again, we'll compile all of these up, so we'll do it array testCompile it up noticeably slower to compile will do the LL test. This is the list versionAnd we'll do the reverse testSo compile them all up on the last repair, so let's run these and get the numbers we've run the array testwe now get nine 165 point seven five as an average for the array will run the link list andWe get one eight five eightPoint six one for the linked list test and now we run the reverse testandWe get 1019.5 five so we've run the test now. So we've we've assumed nothingWe've ran some tests or to get some data so we can see which is faster an array or liquids with this operationWe've been tryingAnd we've got some pretty interesting resultsSo we're running on the atari the linked list was faster than the arrayunless he ran the array backwards in which case the array was faster than the linked list andThe array going forward we'll come back to thatWe ran it on the raspberry Pi and here the array was about twice as fast as the linked listBaby rarely backwards the Array was slower, and if you do it on the IMac view range height, I'm faster than the linked listWhichever way you went so what's going on here?Well, let's ignore the iMac for the minute the apple Haters will love that bitbut let's ignore the Imac for though and let's just have a look at the raspBerry Pi andthe attali so we've gotthe Atari and the Raspberry Pi and we'll just go withThe array speed and the link to this so we've got about one hundred and seventy nineFor that and one hundred and sixty-six clock ticks that now when we can't compare the clock ticks between the different machines because they're differentdifferent clocks used in the machinesbut we can compare them relatively between the same thing on the same machine for the raspberry Pi it was966 andthat was a1859 Kish now what's going on here?Well the thing we need to rememberif you look at the machine codeIt's roughly the same length the same number of operation now on the atari some of the instructions will take slightly longer than to executeBut that's not what gets going on hereWe need to think back to the video onCashiers that we did the difference between the raspberry Pi CPU would have been much faster and more modern and the AtarisIs that the AtAris?Doesn't have a cacheSo every instructionally needs to fetch every bit of data that needs to fetch has to be fetched from memory each timeNo, it's not cachedbroadly speaking we believe something going on there, but broadly speaking with no cache is about half thePrefetch buffer if you want to get into the details, but we can see there's no cashSo if we think about the cPU in the atari, then it's having to accessmemoryFor everything so everything that the cPU needs to fetch on the Atari the instructionsThe data from the array or a linked list and of course the next pointer from the linked list has to come from memorySo it takes the same amount of time we get are the two weather fetching data or fetching instructions on the raspBerry Pi however?We still got the main body the cPU which is going to execute things and it has memoryas wellbut in between there we have a cache in fact we actually probably have two caches one for Data andone for instructions asI want to see if you activate as we looked at in the previous video isAccess to it via the caches, and then they if they haven't got it to get itFrom memory, so why does this make a difference?Surely things will still wake up so well on the atari the fastestthing in the theory is basically the memory the memory is much faster than the cPU that's about twice as fast andSo the memory can provide a data exactly when the cPU needs it. There's no real need for cashMove ahead to the raspberry Pi and the are make of course then the cPU is much faster than the memorySo when cPU ask for something it has to wait while the memory?provides itNow let's figure out how what happens when we run our program?with the arrayon the raspberry PiEvery instruction after the first time will be accessed will be cached in the instruction cacheSo the first time we go through the loop all the instructions are going to be used in that loop will have been cached inThe instruction cap so you can get these immediately the dataparticularly with the array would also collapse a bit with a linked list weDon't get just one or two bytes in each timeI'll get what we call a cache line pickups 128 bytes in a go, so we'll get some of the data that we already needInto the cache as well, so some of the data will already be there in the array more so with your rightso the reason of the array runs faster on the raspberry Pi is that all the instructions are coming straight out of theInstitute basically giving us a fast lane for those instructions, so they get there immediatelyThere's only the data that needs to get from main memory, which will get cached as wellSo the same happens with the route list programExcept for one crucial difference with the linked list poem we have to make one memory accessto get the data value that we're going to sum andThen we have to make another memory access which has to go through the cat into main memoryfor the address of the next thingwe have to make toMemory request which may get satisfied by main Memory hereWhere's our the array one?We only have to make one for the value that we're interested in and because of the cacheWe get sort of a fast passing instructions, and so actually not having to do that second memory access to get the next pointer hereMeans that this the arraylist of the program ends are working about twice as fast on the atari because everything is coming frommemory it doesn't matter whether you're reading an instruction or reading abit of DataIt's still going to come from memory each time so actually the front of the value is already pre-calculated in memory means that actually runsSlightly faster, I mean, we're talking perhaps 10% faster. Not really a billion so we get a slight speed benefitNow to show that this is the caseI took the same version of the program on the atari and ran it on the atari router now the difference for the AtAriSt. We use there and the Falcon is that the falcon has a slightly later version of the 68000 processorwhich has a cacheIn it both instructions and data cache and when I ran that on there the times that came outSo the array was 46 clock ticks is much faster processor anyway, and the link listwas58.5Clock ticks so on the Falcon because you've got the cache. They're just like on the raspberry PiThe array version ends up being traffic exactly the same program exactly the same machine codeBecause you've got the cache there the array version ends up being faster because the instructions of theirProfessional and that sort of fat packs from the cache rather having to go to main memory each timemean that theirradiation becomes faster than the linked list versionNow tell them other things we haven't talked about yet. Why is the reverse array faster on the AtAri?Simple answer to that itJust uses slightly different instructions their instructions on the six 8000 that allow you to do a decrementTesting with zero branch which isn't all in one instructionSo you can actually make the code slightly more compact and run slightly faster again. It's a small enough timeWhy then is the imac significantly faster? We're getting sort of five times faster?Well that's because I use a slightly different compiler that I use the clang CCompiler on the IMac rather than GCC for the other two and it cheats itIt squats that you've got an array axises in the loop, and it says wellOkay, rather than doing a loop around one array accessI will do a loop around eight array accesses all in one goSo it actually removes some of the tests for the loop and it makes the program much faster for the compilers being cleverAnd optimizing the programSo it runs faster the answer to whether the raise faster than the link list or not?Very much depends on how you cpu in the machine that you've built is configured to actually execute the codeSo you can't make assumptions?About how a cpu will execute code you really need to do the test to see what's happening even within the samearchitecture family the difference between the six 8006 8030 in the Falcon mean thatAssumptions we make based on what they charity did where the Rally was slower than the link list aren't true onThe Falcon and when you move it on to a completely different architecture like the raspberry Pi or the X86 chip in the iMacThen again you get different effects, so the best thing is when you're faced with a question question like this, and you're not sureCome up with some test and collect real data, and you'll be able to see what's going oncould you